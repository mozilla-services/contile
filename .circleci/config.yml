# These environment variables must be set in CircleCI UI
#
# DOCKERHUB_REPO - docker hub repo, format: <username>/<repo>
# DOCKERHUB_CONTILE_LOAD_TEST_REPO - docker hub repo for performance test, format: <username>/<repo>
# DOCKER_USER    - login info for docker hub
# DOCKER_PASS
#
version: 2.1

parameters:
  rust-version:
    type: string
    # NOTE: Ensure this Rust version matches the builder's in ../Dockerfile
    default: "1.68"

commands:
  dockerhub-login:
    steps:
      - run:
          name: Login to Dockerhub
          command: |
            if [ "${DOCKER_USER}" == "" ] || [ "${DOCKER_PASS}" == "" ]; then
              echo "Skipping Login to DockerHub, credentials unavailable"
            else
              echo "${DOCKER_PASS}" | docker login -u="${DOCKER_USER}" --password-stdin
            fi
  setup-rust:
    steps:
      - run:
          name: Setup Rust
          command: |
            rustc --version
  setup-rust-check:
    steps:
      - run:
          name: Setup Rust checks
          command: |
            rustup component add rustfmt
            cargo install cargo-audit
            rustup component add clippy
  rust-check:
    steps:
      - run:
          name: Core Rust Checks
          command: |
            cargo fmt -- --check
            cargo audit
  rust-clippy:
    steps:
      - run:
          name: Rust Clippy
          command: |
            cargo clippy --all --all-targets --all-features -- -D warnings
  cargo-build:
    steps:
      - run:
          name: cargo build
          command: cargo build
  write-version:
    steps:
      - run:
          name: Create a version.json
          command: |
            # create a version.json per
            # https://github.com/mozilla-services/Dockerflow/blob/master/docs/version_object.md
            printf '{"commit":"%s","version":"%s","source":"https://github.com/%s/%s","build":"%s"}\n' \
            "$CIRCLE_SHA1" \
            "$CIRCLE_TAG" \
            "$CIRCLE_PROJECT_USERNAME" \
            "$CIRCLE_PROJECT_REPONAME" \
            "$CIRCLE_BUILD_URL" > version.json
  skip-if-do-not-deploy:
    steps:
      - run:
          name: Check if deployment is disallowed
          # This relies on the [do not deploy] text to be available in the
          # merge commit when merging the PR to 'main'.
          command: |
            if git log -1 "$CIRCLE_SHA1" | grep -q '\[do not deploy\]'; then
                echo "Skipping remaining steps in this job: deployment was disabled for this commit."
                circleci-agent step halt

                # No need to deploy, just cancel the rest of jobs of the workflow.
                # See API detail: https://circleci.com/docs/api/v2/index.html#operation/cancelWorkflow

                curl -X POST https://circleci.com/api/v2/workflow/${CIRCLE_WORKFLOW_ID}/cancel \
                -H 'Accept: application/json' \
                -H "Circle-Token: ${SKIP_DEPLOY_API_TOKEN}"
            fi

  run-tests:
    steps:
      - run:
          name: Install cargo2junit
          command: cargo install cargo2junit
      - run:
          name: Install cargo-llvm-cov
          command: cargo install cargo-llvm-cov
      - run:
          name: Run and report tests and coverage (Minimum 67%)
          command: |
            cargo llvm-cov --no-report test -- -Z unstable-options --format json --report-time | cargo2junit > results.xml
            cargo llvm-cov report --fail-under-lines 67 --html
      - store_test_results:
          path: results.xml
      - store_artifacts:
          path: target/llvm-cov/html # Default location
          destination: llvm-cov/html

  setup-sccache:
    steps:
      - run:
          name: Install sccache
          command: |
            cargo install sccache
            # This configures Rust to use sccache.
            echo 'export "RUSTC_WRAPPER"="sccache"' >> $BASH_ENV
            # This is the maximum space sccache cache will use on disk.
            echo 'export "SCCACHE_CACHE_SIZE"="1G"' >> $BASH_ENV
            sccache --version
  restore-sccache-cache:
    steps:
      - restore_cache:
          name: Restore sccache cache
          key: sccache-cache-stable-{{ .Branch }}-{{ .Environment.CIRCLE_JOB }}
  save-sccache-cache:
    steps:
      - save_cache:
          name: Save sccache cache
          key: sccache-cache-stable-{{ .Branch }}-{{ .Environment.CIRCLE_JOB }}-{{ epoch }}
          paths:
            - "~/.cache/sccache"
jobs:
  checks:
    docker:
      - image: cimg/rust:<< pipeline.parameters.rust-version >>
        auth:
          username: $DOCKER_USER
          password: $DOCKER_PASS
    steps:
      - checkout
      - setup-rust
      - setup-rust-check
      - rust-check
      - rust-clippy

  check-for-deployment:
    docker:
      - image: cimg/base:2022.08
    steps:
      - checkout
      - skip-if-do-not-deploy

  test:
    docker:
      - image: cimg/rust:<< pipeline.parameters.rust-version >>
        auth:
          username: $DOCKER_USER
          password: $DOCKER_PASS
        environment:
          RUST_BACKTRACE: 1
          # XXX: begin_test_transaction doesn't play nice over threaded tests
          RUST_TEST_THREADS: 1
    steps:
      - checkout
      - setup-rust
      - cargo-build
      - run-tests

  build:
    docker:
      - image: cimg/rust:<< pipeline.parameters.rust-version >>
        auth:
          username: $DOCKER_USER
          password: $DOCKER_PASS
        environment:
          RUST_BACKTRACE: 1
          # XXX: begin_test_transaction doesn't play nice over threaded tests
          RUST_TEST_THREADS: 1
    steps:
      - setup_remote_docker:
          docker_layer_caching: true
      - dockerhub-login
      #- save-sccache-cache
      - checkout
      - write-version
      - run:
          name: Build Docker image
          command: |
            docker build \
              -t app:build \
              --build-arg VERSION="$(echo ${CIRCLE_SHA1} | cut -c -7)" .
      # save the built docker container into CircleCI's cache. This is
      # required since Workflows do not have the same remote docker instance.
      - run:
          name: docker save app:build
          command: |
            mkdir -p /home/circleci/cache
            docker save -o /home/circleci/cache/docker.tar "app:build"
      - save_cache:
          key: v1-{{ .Branch }}-{{ .Environment.CIRCLE_SHA1 }}-{{ epoch }}
          paths:
            - /home/circleci/cache

  docker-image-publish-stage:
    # The commit tag signals deployment and load test instructions to Jenkins by
    # modifying the Docker image tag name. Pushing a new Docker image to the Docker Hub registry
    # triggers a webhook that starts the Jenkins deployment workflow. The convention looks as follows:
    #^(?P<environment>stage|prod)(?:-(?P<task>\w+)-(?P<onfailure>warn|abort))?-(?P<commit>[a-z0-9]+)$
    docker:
      - image: cimg/base:2022.08
    steps:
      - checkout
      - setup_remote_docker
      - restore_cache:
          key: v1-{{ .Branch }}-{{ .Environment.CIRCLE_SHA1 }}
      - run:
          name: Restore Docker image cache
          command: docker load -i /home/circleci/cache/docker.tar
      - dockerhub-login
      - run:
          name: Deploy to Dockerhub
          command: |
            if git log -1 "$CIRCLE_SHA1" | grep -q '\[load test: warn\]'; then
              echo "Load test requested. Slack warning will be output if test fails and deployment workflow for prod will proceed."
              STAGE_DOCKER_TAG="stage-loadtest-warn-${CIRCLE_SHA1}"
            elif git log -1 "$CIRCLE_SHA1" | grep -q '\[load test: abort\]'; then
              echo "Load test requested. Deployment workflow for prod will abort if load test fails."
              STAGE_DOCKER_TAG="stage-loadtest-abort-${CIRCLE_SHA1}"
            else
              STAGE_DOCKER_TAG="stage-${CIRCLE_SHA1}"
            fi

            echo ${DOCKERHUB_REPO}:${STAGE_DOCKER_TAG}
            docker tag app:build ${DOCKERHUB_REPO}:${STAGE_DOCKER_TAG}
            docker images
            docker push "${DOCKERHUB_REPO}:${STAGE_DOCKER_TAG}"

  docker-image-publish-prod:
    docker:
      - image: cimg/base:2022.08
    steps:
      - setup_remote_docker
      - restore_cache:
          key: v1-{{ .Branch }}-{{ .Environment.CIRCLE_SHA1 }}
      - run:
          name: Restore Docker image cache
          command: docker load -i /home/circleci/cache/docker.tar
      - dockerhub-login
      - run:
          name: Deploy to Dockerhub
          command: |
            PROD_DOCKER_TAG="prod-${CIRCLE_SHA1}"
            echo "${DOCKERHUB_REPO}:${PROD_DOCKER_TAG}"
            docker tag app:build "${DOCKERHUB_REPO}:${PROD_DOCKER_TAG}"
            docker tag app:build "${DOCKERHUB_REPO}:latest"
            docker images
            docker push "${DOCKERHUB_REPO}:${PROD_DOCKER_TAG}"
            docker push "${DOCKERHUB_REPO}:latest"

  contract-test-checks:
    docker:
      - image: cimg/python:3.11
    working_directory: "~/contile/test-engineering/contract-tests"
    steps:
      - checkout:
          path: ~/contile/
      - run:
          name: setup poetry
          command: |
            poetry -V
            poetry install
      - run:
          name: isort
          command: poetry run isort --check-only client partner
      - run:
          name: black
          command: poetry run black --quiet --diff --check client partner
      - run:
          name: flake8
          command: poetry run flake8 client partner
      - run:
          name: mypy
          command: poetry run mypy client partner

  contract-tests:
    machine:
      docker_layer_caching: true
      image: ubuntu-2004:202101-01 # Ubuntu 20.04, Docker v20.10.2, Docker Compose v1.28.2
    working_directory: ~/contile
    steps:
      - checkout
      - restore_cache:
          key: v1-{{ .Branch }}-{{ .Environment.CIRCLE_SHA1 }}
      - run:
          name: Restore Docker image cache
          command: docker load -i /home/circleci/cache/docker.tar
      - run:
          name: Log in to the default Docker registry
          command: |
            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
      - run:
          name: Build client and partner images
          command: |
            docker-compose --version
            docker-compose \
             -f test-engineering/contract-tests/docker-compose.yml \
             build client partner
      - run:
          name: Run contract tests
          command: |
            docker-compose \
             -f test-engineering/contract-tests/docker-compose.yml \
             up --abort-on-container-exit --force-recreate
      - run:
          name: Run "tiles cache" contract tests
          command: |
            docker-compose \
             -f test-engineering/contract-tests/docker-compose.yml \
             -f test-engineering/contract-tests/docker-compose.tiles_cache.yml \
             up --abort-on-container-exit --force-recreate
      - run:
          name: Run "204" contract tests
          command: |
            docker-compose \
             -f test-engineering/contract-tests/docker-compose.yml \
             -f test-engineering/contract-tests/docker-compose.204.yml \
             up --abort-on-container-exit --force-recreate
      - run:
          name: Run "init_error" contract tests
          command: |
            set +e # We need this so that the run doesn't exit after docker-compose
            docker-compose \
             -f test-engineering/contract-tests/docker-compose.yml \
             -f test-engineering/contract-tests/docker-compose.init_error.yml \
             up --abort-on-container-exit --exit-code contile --force-recreate
            contile_exit_code=$?
            if [ "${contile_exit_code}" -eq 0 ]; then
             echo "Expected non-zero exit_code from Contile service"
             exit 1
            else
             echo "Contile service exit_code: ${contile_exit_code}"
             exit 0
            fi

  load-test-checks:
    docker:
      - image: cimg/python:3.11
    working_directory: "~/contile/test-engineering/load"
    steps:
      - checkout:
          path: ~/contile/
      - run:
          name: setup poetry
          command: |
            poetry -V
            poetry install
      - run:
          name: isort
          command: poetry run isort --check-only common locustfiles
      - run:
          name: black
          command: poetry run black --quiet --diff --check common locustfiles
      - run:
          name: flake8
          command: poetry run flake8 common locustfiles
      - run:
          name: mypy
          command: poetry run mypy common locustfiles

  docker-image-publish-locust:
    docker:
      - image: cimg/base:2022.08
    working_directory: "~/contile/test-engineering/load"
    steps:
      - checkout:
          path: ~/contile/
      - run:
          name: Check for load test directive
          command: |
            if ! git log -1 "$CIRCLE_SHA1" | grep -q '\[load test: abort\|warn\]'; then
              echo "Skipping remaining steps in this job: load test not required."
              circleci-agent step halt
            fi
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          name: Build image
          command: docker build -t contile-locust .
      - dockerhub-login
      - run:
          name: Push to Docker Hub
          command: |
            DOCKER_TAG="${CIRCLE_SHA1}"
            echo ${DOCKERHUB_CONTILE_LOAD_TEST_REPO}:${DOCKER_TAG}
            docker tag contile-locust ${DOCKERHUB_CONTILE_LOAD_TEST_REPO}:${DOCKER_TAG}
            docker tag contile-locust ${DOCKERHUB_CONTILE_LOAD_TEST_REPO}:latest
            docker images
            docker push "${DOCKERHUB_CONTILE_LOAD_TEST_REPO}:${DOCKER_TAG}"
            docker push "${DOCKERHUB_CONTILE_LOAD_TEST_REPO}:latest"

workflows:
  version: 2
  pr-workflow:
    jobs:
      - checks: &pr-filters
          filters:
            branches:
              ignore: main
      - build:
          <<: *pr-filters
      - test:
          <<: *pr-filters
      - contract-test-checks:
          <<: *pr-filters
      - contract-tests:
          <<: *pr-filters
          requires:
            - build
            - contract-test-checks
      - load-test-checks:
          <<: *pr-filters

  main-workflow:
    jobs:
      - checks: &main-filters
          filters:
            branches:
              only: main
      - build:
          <<: *main-filters
      - test:
          <<: *main-filters
      - contract-test-checks:
          <<: *main-filters
      - contract-tests:
          <<: *main-filters
          requires:
            - build
            - contract-test-checks
      - load-test-checks:
          <<: *main-filters
      - check-for-deployment:
          <<: *main-filters
          requires:
            - checks
            - test
            - contract-tests
            - load-test-checks
      - docker-image-publish-locust:
          <<: *main-filters
          requires:
            - check-for-deployment
      - docker-image-publish-stage:
          <<: *main-filters
          requires:
            - docker-image-publish-locust
      # The following job will require manual approval in the CircleCI web application.
      # Once provided, and when all the requirements are fullfilled (e.g. tests).
      - unhold-to-deploy:
          <<: *main-filters
          type: approval
          requires:
            - docker-image-publish-stage
      # On approval of the `unhold-to-deploy` job, any successive job that requires it
      # will run. In this case, it's manually triggering deployment to production.
      - docker-image-publish-prod:
          <<: *main-filters
          requires:
            - unhold-to-deploy
